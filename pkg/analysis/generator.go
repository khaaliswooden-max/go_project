package analysis

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"strings"
	"text/template"
)

// LEARN: Code generation eliminates boilerplate and reduces human error.
// Go's text/template package is excellent for generating Go code.
// For complex generation, building AST nodes programmatically gives
// more control and automatic formatting.

// MockSpec describes the interface to generate a mock for.
type MockSpec struct {
	Package    string       // Package name for generated file
	Name       string       // Interface name
	MockName   string       // Name for generated mock (default: Name + "Mock")
	Imports    []string     // Import paths needed
	Methods    []MockMethod // Interface methods
	OutputPath string       // Where to write the file
}

// MockMethod describes a method in the interface.
type MockMethod struct {
	Name    string
	Params  []MockParam
	Results []MockParam
}

// MockParam describes a parameter or result.
type MockParam struct {
	Name string
	Type string
}

// ParamsString returns the parameter list as a string for function signature.
func (m MockMethod) ParamsString() string {
	var parts []string
	for _, p := range m.Params {
		if p.Name != "" {
			parts = append(parts, p.Name+" "+p.Type)
		} else {
			parts = append(parts, p.Type)
		}
	}
	return strings.Join(parts, ", ")
}

// ResultsString returns the result list as a string.
func (m MockMethod) ResultsString() string {
	if len(m.Results) == 0 {
		return ""
	}

	var parts []string
	for _, r := range m.Results {
		parts = append(parts, r.Type)
	}

	if len(m.Results) == 1 {
		return parts[0]
	}
	return "(" + strings.Join(parts, ", ") + ")"
}

// ArgsString returns just the parameter names for calling.
func (m MockMethod) ArgsString() string {
	var parts []string
	for _, p := range m.Params {
		parts = append(parts, p.Name)
	}
	return strings.Join(parts, ", ")
}

// ZeroReturn generates a return statement with zero values.
func (m MockMethod) ZeroReturn() string {
	if len(m.Results) == 0 {
		return "return"
	}

	var zeros []string
	for _, r := range m.Results {
		zeros = append(zeros, zeroValueFor(r.Type))
	}

	return "return " + strings.Join(zeros, ", ")
}

// zeroValueFor returns the zero value for a type.
func zeroValueFor(typeName string) string {
	switch {
	case typeName == "string":
		return `""`
	case typeName == "bool":
		return "false"
	case typeName == "error":
		return "nil"
	case strings.HasPrefix(typeName, "*"):
		return "nil"
	case strings.HasPrefix(typeName, "[]"):
		return "nil"
	case strings.HasPrefix(typeName, "map["):
		return "nil"
	case strings.HasPrefix(typeName, "chan "):
		return "nil"
	case strings.HasPrefix(typeName, "func"):
		return "nil"
	case typeName == "int" || typeName == "int8" || typeName == "int16" ||
		typeName == "int32" || typeName == "int64":
		return "0"
	case typeName == "uint" || typeName == "uint8" || typeName == "uint16" ||
		typeName == "uint32" || typeName == "uint64":
		return "0"
	case typeName == "float32" || typeName == "float64":
		return "0"
	case typeName == "complex64" || typeName == "complex128":
		return "0"
	case typeName == "byte" || typeName == "rune":
		return "0"
	case typeName == "uintptr":
		return "0"
	default:
		// Assume it's a struct type, use empty composite literal
		// This won't always work but is a reasonable default
		return typeName + "{}"
	}
}

// mockTemplate is the template for generating mock implementations.
//
// LEARN: Template guidelines:
// - Add "DO NOT EDIT" header for generated files
// - Use meaningful variable names in template
// - Handle edge cases (no imports, no methods)
const mockTemplate = `// Code generated by glr-gen. DO NOT EDIT.
// Source: {{.Name}}

package {{.Package}}
{{if .Imports}}
import (
{{- range .Imports}}
	"{{.}}"
{{- end}}
)
{{end}}
// {{.MockName}} is a mock implementation of {{.Name}}.
// All methods delegate to the corresponding function fields if set.
type {{.MockName}} struct {
{{- range .Methods}}
	{{.Name}}Func func({{.ParamsString}}) {{.ResultsString}}
{{- end}}
}
{{range .Methods}}
// {{.Name}} implements {{$.Name}}.{{.Name}}.
func (m *{{$.MockName}}) {{.Name}}({{.ParamsString}}) {{.ResultsString}} {
	if m.{{.Name}}Func != nil {
		{{if .Results}}return {{end}}m.{{.Name}}Func({{.ArgsString}}){{if not .Results}}
		return{{end}}
	}
	{{.ZeroReturn}}
}
{{end}}`

// GenerateMock generates a mock implementation for an interface.
//
// LEARN: This function demonstrates template-based code generation.
// The output is properly formatted Go code ready to compile.
func GenerateMock(spec MockSpec) ([]byte, error) {
	// Set default mock name
	if spec.MockName == "" {
		spec.MockName = spec.Name + "Mock"
	}

	// Parse and execute template
	tmpl, err := template.New("mock").Parse(mockTemplate)
	if err != nil {
		return nil, fmt.Errorf("parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, spec); err != nil {
		return nil, fmt.Errorf("execute template: %w", err)
	}

	// Format the output
	// LEARN: go/format.Source formats Go code like gofmt
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted code for debugging
		return buf.Bytes(), fmt.Errorf("format: %w (unformatted output returned)", err)
	}

	return formatted, nil
}

// ExtractInterfaceSpec extracts a MockSpec from an interface in the AST.
//
// LEARN: This shows how to combine AST analysis with code generation.
// We parse the interface definition and extract what we need to
// generate a mock.
func ExtractInterfaceSpec(file *ast.File, fset *token.FileSet, interfaceName string) (*MockSpec, error) {
	spec := &MockSpec{
		Package: file.Name.Name,
		Name:    interfaceName,
	}

	// Find the interface
	var found bool
	ast.Inspect(file, func(n ast.Node) bool {
		typeSpec, ok := n.(*ast.TypeSpec)
		if !ok || typeSpec.Name.Name != interfaceName {
			return true
		}

		iface, ok := typeSpec.Type.(*ast.InterfaceType)
		if !ok {
			return true
		}

		found = true

		// Extract methods
		if iface.Methods != nil {
			for _, method := range iface.Methods.List {
				// Skip embedded interfaces
				if len(method.Names) == 0 {
					continue
				}

				funcType, ok := method.Type.(*ast.FuncType)
				if !ok {
					continue
				}

				mm := MockMethod{
					Name: method.Names[0].Name,
				}

				// Extract parameters
				mm.Params = extractParams(funcType.Params)

				// Extract results
				mm.Results = extractParams(funcType.Results)

				spec.Methods = append(spec.Methods, mm)
			}
		}

		return false // Found it, stop looking
	})

	if !found {
		return nil, fmt.Errorf("interface %s not found", interfaceName)
	}

	// Collect imports that might be needed
	spec.Imports = collectNeededImports(file, spec.Methods)

	return spec, nil
}

// extractParams converts a field list to MockParam slice.
func extractParams(fields *ast.FieldList) []MockParam {
	if fields == nil {
		return nil
	}

	var params []MockParam
	paramNum := 0

	for _, field := range fields.List {
		typeStr := exprToString(field.Type)

		if len(field.Names) == 0 {
			// Anonymous parameter - generate a name
			params = append(params, MockParam{
				Name: fmt.Sprintf("arg%d", paramNum),
				Type: typeStr,
			})
			paramNum++
		} else {
			for _, name := range field.Names {
				params = append(params, MockParam{
					Name: name.Name,
					Type: typeStr,
				})
				paramNum++
			}
		}
	}

	return params
}

// collectNeededImports finds imports that the mock might need.
func collectNeededImports(file *ast.File, methods []MockMethod) []string {
	// Build a map of imported packages
	importMap := make(map[string]string) // alias -> path
	for _, imp := range file.Imports {
		path := strings.Trim(imp.Path.Value, `"`)

		var alias string
		if imp.Name != nil {
			alias = imp.Name.Name
		} else {
			// Default alias is the last path component
			parts := strings.Split(path, "/")
			alias = parts[len(parts)-1]
		}

		importMap[alias] = path
	}

	// Find packages referenced in method signatures
	needed := make(map[string]bool)
	for _, m := range methods {
		for _, p := range m.Params {
			if pkg := extractPackageFromType(p.Type); pkg != "" {
				if path, ok := importMap[pkg]; ok {
					needed[path] = true
				}
			}
		}
		for _, r := range m.Results {
			if pkg := extractPackageFromType(r.Type); pkg != "" {
				if path, ok := importMap[pkg]; ok {
					needed[path] = true
				}
			}
		}
	}

	var imports []string
	for path := range needed {
		imports = append(imports, path)
	}

	return imports
}

// extractPackageFromType finds the package prefix in a type like "context.Context".
func extractPackageFromType(typeStr string) string {
	// Handle pointer and slice prefixes
	typeStr = strings.TrimLeft(typeStr, "*[]")

	// Look for package.Type pattern
	if idx := strings.Index(typeStr, "."); idx > 0 {
		return typeStr[:idx]
	}

	return ""
}

// ============================================================================
// AST-Based Code Generation
// ============================================================================

// LEARN: For complex code generation, building AST nodes gives more control.
// The go/format package then produces properly formatted output.

// CreateStructAST creates an AST for a struct type.
func CreateStructAST(name string, fields []FieldDef) *ast.TypeSpec {
	var fieldList []*ast.Field

	for _, f := range fields {
		field := &ast.Field{
			Type: ast.NewIdent(f.Type),
		}

		if f.Name != "" {
			field.Names = []*ast.Ident{ast.NewIdent(f.Name)}
		}

		if f.Tag != "" {
			field.Tag = &ast.BasicLit{
				Kind:  token.STRING,
				Value: f.Tag,
			}
		}

		fieldList = append(fieldList, field)
	}

	return &ast.TypeSpec{
		Name: ast.NewIdent(name),
		Type: &ast.StructType{
			Fields: &ast.FieldList{
				List: fieldList,
			},
		},
	}
}

// FieldDef defines a struct field for generation.
type FieldDef struct {
	Name string
	Type string
	Tag  string // e.g., `json:"name"`
}

// CreateFunctionAST creates an AST for a simple function.
func CreateFunctionAST(name string, params, results []ParamDef, body []ast.Stmt) *ast.FuncDecl {
	var paramList []*ast.Field
	for _, p := range params {
		paramList = append(paramList, &ast.Field{
			Names: []*ast.Ident{ast.NewIdent(p.Name)},
			Type:  ast.NewIdent(p.Type),
		})
	}

	var resultList []*ast.Field
	for _, r := range results {
		resultList = append(resultList, &ast.Field{
			Type: ast.NewIdent(r.Type),
		})
	}

	funcType := &ast.FuncType{}
	if len(paramList) > 0 {
		funcType.Params = &ast.FieldList{List: paramList}
	}
	if len(resultList) > 0 {
		funcType.Results = &ast.FieldList{List: resultList}
	}

	return &ast.FuncDecl{
		Name: ast.NewIdent(name),
		Type: funcType,
		Body: &ast.BlockStmt{List: body},
	}
}

// ParamDef defines a function parameter or result for generation.
type ParamDef struct {
	Name string
	Type string
}

// CreateReturnStmt creates a return statement with expressions.
func CreateReturnStmt(exprs ...ast.Expr) *ast.ReturnStmt {
	return &ast.ReturnStmt{Results: exprs}
}

// CreateStringLit creates a string literal expression.
func CreateStringLit(value string) *ast.BasicLit {
	return &ast.BasicLit{
		Kind:  token.STRING,
		Value: fmt.Sprintf(`"%s"`, value),
	}
}

// CreateIntLit creates an integer literal expression.
func CreateIntLit(value int) *ast.BasicLit {
	return &ast.BasicLit{
		Kind:  token.INT,
		Value: fmt.Sprintf("%d", value),
	}
}

// CreateCall creates a function call expression.
func CreateCall(funcName string, args ...ast.Expr) *ast.CallExpr {
	return &ast.CallExpr{
		Fun:  ast.NewIdent(funcName),
		Args: args,
	}
}

// CreateSelectorCall creates a method or package function call.
// e.g., CreateSelectorCall("fmt", "Println", ...) -> fmt.Println(...)
func CreateSelectorCall(pkg, name string, args ...ast.Expr) *ast.CallExpr {
	return &ast.CallExpr{
		Fun: &ast.SelectorExpr{
			X:   ast.NewIdent(pkg),
			Sel: ast.NewIdent(name),
		},
		Args: args,
	}
}

// GenerateFromAST converts an AST file to formatted Go source code.
//
// LEARN: format.Node produces gofmt-style output from any AST node.
func GenerateFromAST(node ast.Node) ([]byte, error) {
	var buf bytes.Buffer
	fset := token.NewFileSet()

	if err := format.Node(&buf, fset, node); err != nil {
		return nil, fmt.Errorf("format AST: %w", err)
	}

	return buf.Bytes(), nil
}

// CreateFileAST creates a complete file AST with package and imports.
func CreateFileAST(pkgName string, imports []string, decls ...ast.Decl) *ast.File {
	file := &ast.File{
		Name: ast.NewIdent(pkgName),
	}

	// Add imports
	if len(imports) > 0 {
		var importSpecs []ast.Spec
		for _, imp := range imports {
			importSpecs = append(importSpecs, &ast.ImportSpec{
				Path: &ast.BasicLit{
					Kind:  token.STRING,
					Value: fmt.Sprintf(`"%s"`, imp),
				},
			})
		}

		file.Decls = append(file.Decls, &ast.GenDecl{
			Tok:   token.IMPORT,
			Specs: importSpecs,
		})
	}

	// Add declarations
	file.Decls = append(file.Decls, decls...)

	return file
}

// ============================================================================
// Convenience Generators
// ============================================================================

// GenerateGetter generates a getter method for a struct field.
func GenerateGetter(structName, fieldName, fieldType string) *ast.FuncDecl {
	// Generate: func (s *StructName) FieldName() fieldType { return s.fieldName }

	// Receiver
	recv := &ast.FieldList{
		List: []*ast.Field{
			{
				Names: []*ast.Ident{ast.NewIdent("s")},
				Type: &ast.StarExpr{
					X: ast.NewIdent(structName),
				},
			},
		},
	}

	// Return type
	results := &ast.FieldList{
		List: []*ast.Field{
			{Type: ast.NewIdent(fieldType)},
		},
	}

	// Body: return s.fieldName
	body := &ast.BlockStmt{
		List: []ast.Stmt{
			&ast.ReturnStmt{
				Results: []ast.Expr{
					&ast.SelectorExpr{
						X:   ast.NewIdent("s"),
						Sel: ast.NewIdent(strings.ToLower(fieldName[:1]) + fieldName[1:]),
					},
				},
			},
		},
	}

	return &ast.FuncDecl{
		Recv: recv,
		Name: ast.NewIdent(fieldName),
		Type: &ast.FuncType{
			Results: results,
		},
		Body: body,
	}
}

// GenerateSetter generates a setter method for a struct field.
func GenerateSetter(structName, fieldName, fieldType string) *ast.FuncDecl {
	// Generate: func (s *StructName) SetFieldName(v fieldType) { s.fieldName = v }

	// Receiver
	recv := &ast.FieldList{
		List: []*ast.Field{
			{
				Names: []*ast.Ident{ast.NewIdent("s")},
				Type: &ast.StarExpr{
					X: ast.NewIdent(structName),
				},
			},
		},
	}

	// Parameters
	params := &ast.FieldList{
		List: []*ast.Field{
			{
				Names: []*ast.Ident{ast.NewIdent("v")},
				Type:  ast.NewIdent(fieldType),
			},
		},
	}

	// Body: s.fieldName = v
	body := &ast.BlockStmt{
		List: []ast.Stmt{
			&ast.AssignStmt{
				Lhs: []ast.Expr{
					&ast.SelectorExpr{
						X:   ast.NewIdent("s"),
						Sel: ast.NewIdent(strings.ToLower(fieldName[:1]) + fieldName[1:]),
					},
				},
				Tok: token.ASSIGN,
				Rhs: []ast.Expr{ast.NewIdent("v")},
			},
		},
	}

	return &ast.FuncDecl{
		Recv: recv,
		Name: ast.NewIdent("Set" + fieldName),
		Type: &ast.FuncType{
			Params: params,
		},
		Body: body,
	}
}

